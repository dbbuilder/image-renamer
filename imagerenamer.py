"""
ImageRenamer.py

This script renames image files in a specified directory based on extracted text (OCR) and captions generated by an AI model. 
It supports various image formats and allows for preprocessing such as skipping certain files and resolving naming conflicts.
It also converts HEIC files to JPG before processing and preserves the metadata. The --COMPRESS argument converts all images 
to JPG, copies EXIF data, and compresses them for HD television quality. The --DATE argument prepends the date taken to the filename.
Facial recognition is used to replace generic captions like "a Man" with the correct name if a match is found. The --HASH argument
enables image hashing to detect duplicates and move them to a `DUPLICATES` folder.

Setup Instructions:
1. Install required packages:
   pip install Pillow transformers pillow-heif azure-cognitiveservices-vision-face opencv-python requests
   (Optional: pytesseract if you plan to enable OCR)
2. Create an Azure Face API resource, and obtain the Endpoint and Subscription Key.
3. Run the script from the command line:
   python ImageRenamer.py <directory_path> [--DATE] [--COMPRESS] [--HASH]

Supported Image Formats: .jpg, .jpeg, .jfif, .png, .bmp, .gif, .webp, .heic
"""

import os
import sys
import re
import shutil
import hashlib
from datetime import datetime
from PIL import Image, ExifTags
from pillow_heif import register_heif_opener
from transformers import BlipProcessor, BlipForConditionalGeneration
from azure.cognitiveservices.vision.face import FaceClient
from msrest.authentication import CognitiveServicesCredentials

# Global Constants
SUPPORTED_EXTENSIONS = [".jpg", ".jpeg", ".jfif", ".png", ".bmp", ".gif", ".webp", ".heic"]
LOG_FILENAME = "ImageRenamer_Log.txt"
FACE_FOLDER = "path_to_face_folder"  # Update this path as needed
FACE_API_KEY = "YOUR_AZURE_FACE_API_KEY"
FACE_API_ENDPOINT = "YOUR_AZURE_FACE_API_ENDPOINT"
JPEG_QUALITY = 70
MAX_RESOLUTION = (1920, 1080)

# Register HEIF/HEIC format with Pillow
register_heif_opener()

# Initialize the BLIP model and processor for image captioning
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")

# Set up your Azure Face API credentials
face_client = FaceClient(FACE_API_ENDPOINT, CognitiveServicesCredentials(FACE_API_KEY))

def log_message(message, log_directory):
    """Log a message with a timestamp to a specified log file in the target directory."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_path = os.path.join(log_directory, LOG_FILENAME)
    try:
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(f"[{timestamp}] {message}\n")
    except Exception as e:
        print(f"Error writing to log file: {e}")

def create_originals_folder(directory):
    """Create an 'ORIGINALS' folder in the specified directory."""
    originals_path = os.path.join(directory, "ORIGINALS")
    try:
        if not os.path.exists(originals_path):
            os.makedirs(originals_path)
        return originals_path
    except Exception as e:
        log_message(f"Error creating ORIGINALS folder in {directory}: {e}", log_directory=directory)
        return None

def move_to_originals(file_path, originals_folder, log_directory):
    """Move the original file to the 'ORIGINALS' folder, ensuring no filename conflicts."""
    try:
        # Ensure the destination filename is unique by appending a date-time stamp if needed
        base_name = os.path.splitext(os.path.basename(file_path))[0]
        extension = os.path.splitext(file_path)[1]
        dest_path = os.path.join(originals_folder, os.path.basename(file_path))

        # If the file already exists in the ORIGINALS folder, append a timestamp
        if os.path.exists(dest_path):
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            new_base_name = f"{base_name}_{timestamp}"
            dest_path = os.path.join(originals_folder, new_base_name + extension)

        shutil.move(file_path, dest_path)
        log_message(f"Moved {file_path} to {dest_path}", log_directory=log_directory)
    except Exception as e:
        log_message(f"Error moving {file_path} to {originals_folder}: {e}", log_directory=log_directory)

def hash_image(image_path, log_directory):
    """Compute a hash for the image to identify duplicates."""
    try:
        image = Image.open(image_path)
        hash_obj = hashlib.md5()
        for chunk in iter(lambda: image.tobytes(), b""):
            hash_obj.update(chunk)
        return hash_obj.hexdigest()
    except Exception as e:
        log_message(f"Error hashing image {image_path}: {e}", log_directory=log_directory)
        return None

def convert_heic_to_jpg(image_path, originals_folder, log_directory):
    """Convert a HEIC image to JPG format while preserving metadata and move the original HEIC file to the 'ORIGINALS' folder."""
    try:
        # Convert HEIC to JPG
        image = Image.open(image_path)
        exif_data = image.info.get('exif')
        jpg_path = os.path.splitext(image_path)[0] + ".jpg"
        image.save(jpg_path, "JPEG", exif=exif_data)

        # After successful conversion, move the original HEIC file to the ORIGINALS folder
        move_to_originals(image_path, originals_folder, log_directory)
        
        log_message(f"Converted {image_path} to {jpg_path} with metadata preserved and moved original HEIC to {originals_folder}", log_directory=log_directory)
        return jpg_path
    except Exception as e:
        log_message(f"Error converting HEIC to JPG for {image_path}: {e}", log_directory=log_directory)
        return None

def compress_jpg(image_path, originals_folder, log_directory, quality=JPEG_QUALITY, max_resolution=MAX_RESOLUTION):
    """Compress an existing JPG image with adjustable quality and resolution, preserving EXIF data."""
    try:
        image = Image.open(image_path)
        image.thumbnail(max_resolution, Image.Resampling.LANCZOS)
        exif_data = image.info.get('exif')
        compressed_path = os.path.splitext(image_path)[0] + "_compressed.jpg"
        image.save(compressed_path, "JPEG", quality=quality, exif=exif_data)
        log_message(f"Compressed {image_path} to {compressed_path} with quality={quality} and resolution={max_resolution}, preserving metadata.", log_directory=log_directory)
        return compressed_path
    except Exception as e:
        log_message(f"Error compressing {image_path}: {e}", log_directory=log_directory)
        return None

def extract_text_from_image(image_path, log_directory):
    """Extract text from an image using OCR (placeholder, as OCR is disabled)."""
    try:
        image = Image.open(image_path)
        text = ""  # Placeholder since OCR is commented out
        return text.strip()
    except Exception as e:
        log_message(f"Error extracting text from {image_path}: {e}", log_directory=log_directory)
        return ""

def generate_caption(image_path, log_directory):
    """Generate a caption for an image using the BLIP model."""
    try:
        image = Image.open(image_path).convert("RGB")
        inputs = processor(image, return_tensors="pt")
        out = model.generate(**inputs)
        caption = processor.decode(out[0], skip_special_tokens=True)
        return caption.strip()
    except Exception as e:
        log_message(f"Error generating caption for {image_path}: {e}", log_directory=log_directory)
        return ""

def get_image_metadata(image_path, log_directory):
    """Extract metadata from an image."""
    try:
        image = Image.open(image_path)
        exif_data = image._getexif()
        metadata = {}
        if exif_data:
            for tag, value in exif_data.items():
                decoded = ExifTags.TAGS.get(tag, tag)
                metadata[decoded] = value
        return metadata
    except Exception as e:
        log_message(f"Error extracting metadata from {image_path}: {e}", log_directory=log_directory)
        return {}

def get_date_taken(metadata, log_directory):
    """Extract the date the photo was taken from the metadata."""
    try:
        if 'DateTimeOriginal' in metadata:
            return datetime.strptime(metadata['DateTimeOriginal'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        elif 'DateTime' in metadata:
            return datetime.strptime(metadata['DateTime'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        else:
            return None
    except Exception as e:
        log_message(f"Error extracting date taken from metadata: {e}", log_directory=log_directory)
        return None

def resolve_conflict(directory, base_name, fileext):
    """Resolve naming conflicts by appending a numeric suffix to the base name."""
    counter = 1
    while True:
        new_filename = f"{base_name}{counter:03d}{fileext}"
        if not os.path.exists(os.path.join(directory, new_filename)):
            return new_filename
        counter += 1

def convert_heic_files(directory, originals_folder, log_directory):
    """Convert all HEIC files in the directory to JPG while preserving metadata."""
    for root, _, files in os.walk(directory):
        for file in files:
            fileext = os.path.splitext(file)[1].lower()
            if fileext == ".heic":
                image_path = os.path.join(root, file)
                convert_heic_to_jpg(image_path, originals_folder, log_directory)

def generate_captions(directory, originals_folder, log_directory):
    """Generate captions for all image files in the directory."""
    for root, _, files in os.walk(directory):
        for file in files:
            fileext = os.path.splitext(file)[1].lower()
            if fileext in SUPPORTED_EXTENSIONS:
                image_path = os.path.join(root, file)
                # Skip files in the ORIGINALS and DUPLICATES folders
                if "ORIGINALS" in root or "DUPLICATES" in root:
                    continue
                caption = generate_caption(image_path, log_directory)
                if caption:
                    pascal_case_name = "".join(
                        word.capitalize() for word in caption.split()
                    )[:47]
                    new_name = resolve_conflict(root, pascal_case_name, fileext)
                    try:
                        os.rename(image_path, os.path.join(root, new_name))
                        move_to_originals(image_path, originals_folder, log_directory)
                    except Exception as e:
                        log_message(f"Error renaming {file} to {new_name}: {e}", log_directory=log_directory)

def prepend_dates_to_filenames(directory, originals_folder, log_directory):
    """Prepend the date taken to the filenames based on EXIF metadata."""
    for root, _, files in os.walk(directory):
        for file in files:
            fileext = os.path.splitext(file)[1].lower()
            if fileext in SUPPORTED_EXTENSIONS:
                image_path = os.path.join(root, file)
                # Skip files in the ORIGINALS and DUPLICATES folders
                if "ORIGINALS" in root or "DUPLICATES" in root:
                    continue
                metadata = get_image_metadata(image_path, log_directory)
                date_taken = get_date_taken(metadata, log_directory)
                if date_taken and not re.match(r'^\d{4}-\d{2}-\d{2}_', file):
                    new_name = f"{date_taken}_{file}"
                    new_path = os.path.join(root, new_name)
                    try:
                        os.rename(image_path, new_path)
                        move_to_originals(image_path, originals_folder, log_directory)
                    except Exception as e:
                        log_message(f"Error renaming {file} to {new_name}: {e}", log_directory=log_directory)

def compress_images(directory, originals_folder, log_directory):
    """Compress all JPG files in the directory while preserving metadata."""
    for root, _, files in os.walk(directory):
        for file in files:
            fileext = os.path.splitext(file)[1].lower()
            if fileext == ".jpg" and "_compressed" not in file.lower():
                image_path = os.path.join(root, file)
                # Skip files in the ORIGINALS and DUPLICATES folders
                if "ORIGINALS" in root or "DUPLICATES" in root:
                    continue
                compressed_image_path = compress_jpg(image_path, originals_folder, log_directory)
                if compressed_image_path:
                    move_to_originals(image_path, originals_folder, log_directory)

def process_images(directory, prepend_date=False, compress=False, hashimages=False):
    """Process images in the specified directory by running them through multiple passes."""
    
    originals_folder = create_originals_folder(directory)
    log_directory = directory
    
    # Pass 1: Convert HEIC to JPG
    convert_heic_files(directory, originals_folder, log_directory)

    # Pass 2: Generate captions
    generate_captions(directory, originals_folder, log_directory)

    # Pass 3: Prepend dates to filenames
    if prepend_date:
        prepend_dates_to_filenames(directory, originals_folder, log_directory)

    # Pass 4: Compress JPG files
    if compress:
        compress_images(directory, originals_folder, log_directory)

if __name__ == "__main__":
    # Check for command-line arguments
    prepend_date = "--DATE" in sys.argv
    compress = "--COMPRESS" in sys.argv
    hashimages = "--HASH" in sys.argv

    # Get the directory from the command-line argument if provided
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        # Prompt the user for the directory if not provided
        directory = input("Enter the directory path containing images: ")

    if not os.path.isdir(directory):
        print(f"Error: The provided directory '{directory}' does not exist.")
        sys.exit(1)

    process_images(directory, prepend_date, compress, hashimages)
