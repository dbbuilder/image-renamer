"""
ImageRenamer.py

This script renames image files in a specified directory based on extracted text (OCR) and captions generated by an AI model. 
It supports various image formats and allows for preprocessing such as skipping certain files and resolving naming conflicts.
It also converts HEIC files to JPG before processing and preserves the metadata. The --COMPRESS argument converts all images 
to JPG, copies EXIF data, and compresses them for HD television quality. The --DATE argument prepends the date taken to the filename.
Facial recognition is used to replace generic captions like "a Man" with the correct name if a match is found.

Setup Instructions:
1. Install required packages:
   pip install Pillow transformers pillow-heif azure-cognitiveservices-vision-face opencv-python requests
   (Optional: pytesseract if you plan to enable OCR)
2. Create an Azure Face API resource, and obtain the Endpoint and Subscription Key.
3. Run the script from the command line:
   python ImageRenamer.py <directory_path> [--DATE] [--COMPRESS]

Supported Image Formats: .jpg, .jpeg, .jfif, .png, .bmp, .gif, .webp, .heic
"""

import os
import sys
import re
import cv2
import requests
from datetime import datetime
from PIL import Image, ExifTags
from pillow_heif import register_heif_opener
from transformers import BlipProcessor, BlipForConditionalGeneration
from azure.cognitiveservices.vision.face import FaceClient
from msrest.authentication import CognitiveServicesCredentials

# Register HEIF/HEIC format with Pillow
register_heif_opener()

# Global constant for supported image file formats
SUPPORTED_EXTENSIONS = [".jpg", ".jpeg", ".jfif", ".png", ".bmp", ".gif", ".webp", ".heic"]

# Initialize the BLIP model and processor for image captioning
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")

# Set up your Azure Face API credentials
FACE_API_KEY = "YOUR_AZURE_FACE_API_KEY"
FACE_API_ENDPOINT = "YOUR_AZURE_FACE_API_ENDPOINT"

face_client = FaceClient(FACE_API_ENDPOINT, CognitiveServicesCredentials(FACE_API_KEY))

# Constant for the face folder path
FACE_FOLDER = "path_to_face_folder"  # Update this path as needed

def detect_faces(image_path):
    """Detect faces in an image and return face IDs using Azure Face API."""
    try:
        with open(image_path, "rb") as image_data:
            detected_faces = face_client.face.detect_with_stream(image_data, detection_model='detection_03')
            return [face.face_id for face in detected_faces]
    except Exception as e:
        log_message(f"Error detecting faces in {image_path}: {e}")
        return []

def match_faces(target_image_path):
    """Match faces in the target image to the known faces in the face folder."""
    try:
        if not os.path.exists(FACE_FOLDER):
            log_message(f"Face folder '{FACE_FOLDER}' does not exist. Skipping face recognition.")
            return None

        # Load known faces and their names
        known_faces = {}
        for filename in os.listdir(FACE_FOLDER):
            if filename.lower().endswith(".jpg"):
                face_image_path = os.path.join(FACE_FOLDER, filename)
                face_ids = detect_faces(face_image_path)
                if face_ids:
                    known_faces[face_ids[0]] = os.path.splitext(filename)[0]  # Assume one face per image

        # Detect faces in the target image
        target_face_ids = detect_faces(target_image_path)

        # Attempt to match each face in the target image to the known faces
        for target_face_id in target_face_ids:
            results = face_client.face.find_similar(face_id=target_face_id, face_ids=list(known_faces.keys()))
            if results:
                matched_face_id = results[0].face_id
                matched_name = known_faces[matched_face_id]
                return matched_name

        return None
    except Exception as e:
        log_message(f"Error matching faces in {target_image_path}: {e}")
        return None

def convert_to_jpg(image_path):
    """Convert any supported image format to JPG while preserving metadata and compressing it."""
    try:
        image = Image.open(image_path)
        
        # Extract the EXIF data from the image
        exif_data = image.info.get('exif')
        
        # Convert image to JPG path
        jpg_path = os.path.splitext(image_path)[0] + ".jpg"
        
        # Save the image as JPG with the EXIF data, compressing it for HD television quality
        image.save(jpg_path, "JPEG", exif=exif_data, quality=85)  # 85 is a good balance for quality and compression
        
        log_message(f"Converted and compressed {image_path} to {jpg_path}")
        return jpg_path
    except Exception as e:
        log_message(f"Error converting {image_path} to JPG: {e}")
        return None

def compress_jpg(image_path):
    """Compress an existing JPG image."""
    try:
        image = Image.open(image_path)
        
        # Extract the EXIF data from the image
        exif_data = image.info.get('exif')
        
        # Compress the image
        compressed_path = os.path.splitext(image_path)[0] + "_compressed.jpg"
        image.save(compressed_path, "JPEG", exif=exif_data, quality=85)  # 85 is a good balance for quality and compression
        
        log_message(f"Compressed {image_path} to {compressed_path}")
        return compressed_path
    except Exception as e:
        log_message(f"Error compressing {image_path}: {e}")
        return None

def convert_heic_to_jpg(image_path):
    """Convert a HEIC image to JPG format while preserving metadata."""
    try:
        # Open the HEIC image using Pillow
        image = Image.open(image_path)
        
        # Extract the EXIF data from the HEIC image
        exif_data = image.info.get('exif')

        # Convert to JPG path
        jpg_path = os.path.splitext(image_path)[0] + ".jpg"
        
        # Save the image as JPG with the EXIF data
        image.save(jpg_path, "JPEG", exif=exif_data)
        
        log_message(f"Converted {image_path} to {jpg_path} with metadata preserved")
        return jpg_path
    except Exception as e:
        log_message(f"Error converting HEIC to JPG for {image_path}: {e}")
        return None

def extract_text_from_image(image_path):
    """Extract text from an image using OCR (placeholder, as OCR is disabled)."""
    try:
        image = Image.open(image_path)
        # Use pytesseract to extract text from the image (uncomment if OCR is needed)
        # text = pytesseract.image_to_string(image)
        text = ""  # Placeholder since OCR is commented out
        return text.strip()
    except Exception as e:
        log_message(f"Error extracting text from {image_path}: {e}")
        return ""

def generate_caption(image_path):
    """Generate a caption for an image using the BLIP model."""
    try:
        image = Image.open(image_path).convert("RGB")
        inputs = processor(image, return_tensors="pt")
        out = model.generate(**inputs)
        caption = processor.decode(out[0], skip_special_tokens=True)
        return caption.strip()
    except Exception as e:
        log_message(f"Error generating caption for {image_path}: {e}")
        return ""

def get_image_metadata(image_path):
    """Extract metadata from an image."""
    try:
        image = Image.open(image_path)
        exif_data = image._getexif()
        metadata = {}
        
        if exif_data:
            for tag, value in exif_data.items():
                decoded = ExifTags.TAGS.get(tag, tag)
                metadata[decoded] = value
                
        return metadata
    except Exception as e:
        log_message(f"Error extracting metadata from {image_path}: {e}")
        return {}

def get_date_taken(metadata):
    """Extract the date the photo was taken from the metadata."""
    try:
        if 'DateTimeOriginal' in metadata:
            return datetime.strptime(metadata['DateTimeOriginal'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        elif 'DateTime' in metadata:
            return datetime.strptime(metadata['DateTime'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        else:
            return None
    except Exception as e:
        log_message(f"Error extracting date taken from metadata: {e}")
        return None

def resolve_conflict(directory, base_name, fileext):
    """Resolve naming conflicts by appending a numeric suffix to the base name."""
    counter = 1
    while True:
        new_filename = f"{base_name}{counter:03d}{fileext}"
        if not os.path.exists(os.path.join(directory, new_filename)):
            return new_filename
        counter += 1

def log_message(message, log_filename="ImageRenamer_Log.txt", log_directory="."):
    """Log a message with a timestamp to a specified log file in the target directory."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_path = os.path.join(log_directory, log_filename)
    try:
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(f"[{timestamp}] {message}\n")
    except Exception as e:
        print(f"Error writing to log file: {e}")

def process_images(directory, prepend_date=False, compress=False):
    """Process images in the specified directory: rename them based on extracted text and generated captions."""
    files_exist = any(
        file.lower().endswith(tuple(SUPPORTED_EXTENSIONS))
        for file in os.listdir(directory)
    )
    
    if not files_exist:
        log_message("No image files found with supported extensions.", log_directory=directory)
        print("No image files found with supported extensions.")
        return  # Exit the function if no matching files are found

    for root, _, files in os.walk(directory):
        for file in files:
            image_path = os.path.join(root, file)
            fileext = os.path.splitext(image_path)[1].lower()

            # Convert to JPG if needed (and compress if --COMPRESS is used)
            if fileext != ".jpg" and compress:
                image_path = convert_to_jpg(image_path)
                if not image_path:  # Skip if conversion failed
                    continue
                fileext = ".jpg"
            elif fileext == ".jpg" and compress:
                image_path = compress_jpg(image_path)
                if not image_path:  # Skip if compression failed
                    continue

            # Convert HEIC to JPG if needed
            if fileext == ".heic":
                image_path = convert_heic_to_jpg(image_path)
                if not image_path:  # Skip if conversion failed
                    continue
                fileext = ".jpg"

            # Extract date taken from metadata
            metadata = get_image_metadata(image_path)
            date_taken = get_date_taken(metadata) if prepend_date else None

            # Prepend date to the filename if needed
            if prepend_date and date_taken:
                base_name = f"{date_taken}_{os.path.splitext(file)[0]}"
            else:
                base_name = os.path.splitext(file)[0]

            # If the file ends with a number in the range 001 to 009, apply --DATE and --COMPRESS but skip renaming
            if re.search(r"00[1-9]\.\w+$", file.lower()):
                if prepend_date or compress:
                    # Still apply date prepend or compression
                    if prepend_date and date_taken:
                        new_name = f"{date_taken}_{file}"
                        new_path = os.path.join(root, new_name)
                        try:
                            os.rename(image_path, new_path)
                            log_message(f"Date prepended for {file} to {new_name}", log_directory=directory)
                        except Exception as e:
                            log_message(f"Error prepending date for {file} to {new_name}: {e}", log_directory=directory)
                continue  # Skip further renaming/caption processing

            # Extract OCR text (currently disabled)
            ocr_text = extract_text_from_image(image_path)

            # Generate image caption
            caption = generate_caption(image_path)

            # Replace generic captions with the recognized face name if a match is found
            if os.path.exists(FACE_FOLDER):
                matched_name = match_faces(image_path)
                if matched_name:
                    caption = caption.replace("a Man", matched_name).replace("a Woman", matched_name)

            # Combine OCR text and caption, truncate to 47 characters, and PascalCase
            combined_text = (ocr_text + " " + caption).strip()
            pascal_case_name = "".join(
                word.capitalize() for word in combined_text.split()
            )[:47]  # Truncate to 47 characters

            # Always add the number suffix (001, 002, etc.)
            if pascal_case_name:
                base_name = pascal_case_name
                if prepend_date and date_taken:
                    base_name = f"{date_taken}_{base_name}"

                new_name = resolve_conflict(root, base_name, fileext)
                new_path = os.path.join(root, new_name)
                try:
                    os.rename(image_path, new_path)
                    log_message(f"Renamed {file} to {new_name}", log_directory=directory)
                except Exception as e:
                    log_message(f"Error renaming {file} to {new_name}: {e}", log_directory=directory)

if __name__ == "__main__":
    # Check for command-line arguments
    prepend_date = "--DATE" in sys.argv
    compress = "--COMPRESS" in sys.argv

    # Get the directory from the command-line argument if provided
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        # Prompt the user for the directory if not provided
        directory = input("Enter the directory path containing images: ")

    if not os.path.isdir(directory):
        print(f"Error: The provided directory '{directory}' does not exist.")
        sys.exit(1)

    process_images(directory, prepend_date, compress)
