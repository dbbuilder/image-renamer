"""
ImageRenamer.py

This script renames image files in a specified directory based on extracted text (OCR) and captions generated by an AI model. 
It supports various image formats and allows for preprocessing such as skipping certain files and resolving naming conflicts.

Setup Instructions:
1. Install required packages:
   pip install Pillow transformers
   (Optional: pytesseract if you plan to enable OCR)
2. Ensure Tesseract-OCR is installed if OCR is used. Set the Tesseract path in the script if necessary.
3. Run the script from the command line:
   python ImageRenamer.py <directory_path> [--DATE]

Supported Image Formats: .jpg, .jpeg, .jfif, .png, .bmp, .gif, .webp, .heic
"""

import os
import sys
import re
from datetime import datetime
from PIL import Image, ExifTags
from transformers import BlipProcessor, BlipForConditionalGeneration

# Global constant for supported image file formats
SUPPORTED_EXTENSIONS = [".jpg", ".jpeg", ".jfif", ".png", ".bmp", ".gif", ".webp", ".heic"]

# Initialize the BLIP model and processor for image captioning
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")

def extract_text_from_image(image_path):
    """Extract text from an image using OCR (placeholder, as OCR is disabled)."""
    try:
        image = Image.open(image_path)
        # Use pytesseract to extract text from the image
        # text = pytesseract.image_to_string(image)
        text = ""  # Placeholder since OCR is commented out
        return text.strip()
    except Exception as e:
        log_message(f"Error extracting text from {image_path}: {e}")
        return ""

def get_image_metadata(image_path):
    """Extract metadata from an image."""
    try:
        image = Image.open(image_path)
        exif_data = image._getexif()
        metadata = {}
        
        if exif_data:
            for tag, value in exif_data.items():
                decoded = ExifTags.TAGS.get(tag, tag)
                metadata[decoded] = value
                
        return metadata
    except Exception as e:
        log_message(f"Error extracting metadata from {image_path}: {e}")
        return {}

def get_date_taken(metadata):
    """Extract the date the photo was taken from the metadata."""
    try:
        if 'DateTimeOriginal' in metadata:
            return datetime.strptime(metadata['DateTimeOriginal'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        elif 'DateTime' in metadata:
            return datetime.strptime(metadata['DateTime'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        else:
            return None
    except Exception as e:
        log_message(f"Error extracting date taken from metadata: {e}")
        return None

def resolve_conflict(directory, base_name, fileext):
    """Resolve naming conflicts by appending a numeric suffix to the base name."""
    counter = 1
    while True:
        new_filename = f"{base_name}{counter:03d}{fileext}"
        if not os.path.exists(os.path.join(directory, new_filename)):
            return new_filename
        counter += 1

def log_message(message, log_filename="ImageRenamer_Log.txt", log_directory="."):
    """Log a message with a timestamp to a specified log file in the target directory."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_path = os.path.join(log_directory, log_filename)
    try:
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(f"[{timestamp}] {message}\n")
    except Exception as e:
        print(f"Error writing to log file: {e}")

def process_images(directory, prepend_date=False):
    """Process images in the specified directory: rename them based on extracted text and generated captions."""
    files_exist = any(
        file.lower().endswith(tuple(SUPPORTED_EXTENSIONS))
        for file in os.listdir(directory)
    )
    
    if not files_exist:
        log_message("No image files found with supported extensions.")
        print("No image files found with supported extensions.")
        return  # Exit the function if no matching files are found

    for root, _, files in os.walk(directory):
        for file in files:
            # Skip files that end with a number in the range 001 to 009
            if re.search(r"00[1-9]\.\w+$", file.lower()):
                log_message(f"Skipping {file}: ends with a number in the range 001-009.")
                continue

            # Process files with supported image extensions
            if file.lower().endswith(tuple(SUPPORTED_EXTENSIONS)):
                image_path = os.path.join(root, file)
                fileext = os.path.splitext(image_path)[1].lower()

                # Extract date taken from metadata
                metadata = get_image_metadata(image_path)
                date_taken = get_date_taken(metadata) if prepend_date else None

                # Prepend date to the filename if needed
                if prepend_date and date_taken:
                    base_name = f"{date_taken}_{os.path.splitext(file)[0]}"
                else:
                    base_name = os.path.splitext(file)[0]

                # Extract OCR text (currently disabled)
                ocr_text = extract_text_from_image(image_path)

                # Generate image caption
                caption = generate_caption(image_path)

                # Combine OCR text and caption, truncate to 47 characters, and PascalCase
                combined_text = (ocr_text + " " + caption).strip()
                pascal_case_name = "".join(
                    word.capitalize() for word in combined_text.split()
                )[:47]  # Truncate to 47 characters

                # Always add the number suffix (001, 002, etc.)
                if pascal_case_name:
                    base_name = pascal_case_name
                    if prepend_date and date_taken:
                        base_name = f"{date_taken}_{base_name}"

                    new_name = resolve_conflict(root, base_name, fileext)
                    new_path = os.path.join(root, new_name)
                    try:
                        os.rename(image_path, new_path)
                        log_message(f"Renamed {file} to {new_name}")
                    except Exception as e:
                        log_message(f"Error renaming {file} to {new_name}: {e}")

if __name__ == "__main__":
    # Check for command-line arguments
    prepend_date = "--DATE" in sys.argv

    # Get the directory from the command-line argument if provided
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        # Prompt the user for the directory if not provided
        directory = input("Enter the directory path containing images: ")

    if not os.path.isdir(directory):
        print(f"Error: The provided directory '{directory}' does not exist.")
        sys.exit(1)

    process_images(directory, prepend_date)
