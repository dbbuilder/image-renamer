"""
ImageRenamer.py

This script renames image files in a specified directory based on extracted text (OCR) and captions generated by an AI model. 
It supports various image formats and allows for preprocessing such as skipping certain files and resolving naming conflicts.
It also converts HEIC files to JPG before processing and preserves the metadata. The --COMPRESS argument converts all images 
to JPG, copies EXIF data, and compresses them for HD television quality.

Setup Instructions:
1. Install required packages:
   pip install Pillow transformers pillow-heif
   (Optional: pytesseract if you plan to enable OCR)
2. Ensure Tesseract-OCR is installed if OCR is used. Set the Tesseract path in the script if necessary.
3. Run the script from the command line:
   python ImageRenamer.py <directory_path> [--DATE] [--COMPRESS]

Supported Image Formats: .jpg, .jpeg, .jfif, .png, .bmp, .gif, .webp, .heic
"""

import os
import sys
import re
from datetime import datetime
from PIL import Image, ExifTags
from pillow_heif import register_heif_opener
from transformers import BlipProcessor, BlipForConditionalGeneration

# Register HEIF/HEIC format with Pillow
register_heif_opener()

# Global constant for supported image file formats
SUPPORTED_EXTENSIONS = [".jpg", ".jpeg", ".jfif", ".png", ".bmp", ".gif", ".webp", ".heic"]

# Initialize the BLIP model and processor for image captioning
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
model = BlipForConditionalGeneration.from_pretrained("Salesforce/blip-image-captioning-base")

def convert_to_jpg(image_path):
    """Convert any supported image format to JPG while preserving metadata and compressing it."""
    try:
        image = Image.open(image_path)
        
        # Extract the EXIF data from the image
        exif_data = image.info.get('exif')
        
        # Convert image to JPG path
        jpg_path = os.path.splitext(image_path)[0] + ".jpg"
        
        # Save the image as JPG with the EXIF data, compressing it for HD television quality
        image.save(jpg_path, "JPEG", exif=exif_data, quality=85)  # 85 is a good balance for quality and compression
        
        log_message(f"Converted and compressed {image_path} to {jpg_path}")
        return jpg_path
    except Exception as e:
        log_message(f"Error converting {image_path} to JPG: {e}")
        return None

def compress_jpg(image_path):
    """Compress an existing JPG image."""
    try:
        image = Image.open(image_path)
        
        # Extract the EXIF data from the image
        exif_data = image.info.get('exif')
        
        # Compress the image
        compressed_path = os.path.splitext(image_path)[0] + "_compressed.jpg"
        image.save(compressed_path, "JPEG", exif=exif_data, quality=85)  # 85 is a good balance for quality and compression
        
        log_message(f"Compressed {image_path} to {compressed_path}")
        return compressed_path
    except Exception as e:
        log_message(f"Error compressing {image_path}: {e}")
        return None

def convert_heic_to_jpg(image_path):
    """Convert a HEIC image to JPG format while preserving metadata."""
    try:
        # Open the HEIC image using Pillow
        image = Image.open(image_path)
        
        # Extract the EXIF data from the HEIC image
        exif_data = image.info.get('exif')

        # Convert to JPG path
        jpg_path = os.path.splitext(image_path)[0] + ".jpg"
        
        # Save the image as JPG with the EXIF data
        image.save(jpg_path, "JPEG", exif=exif_data)
        
        log_message(f"Converted {image_path} to {jpg_path} with metadata preserved")
        return jpg_path
    except Exception as e:
        log_message(f"Error converting HEIC to JPG for {image_path}: {e}")
        return None

def extract_text_from_image(image_path):
    """Extract text from an image using OCR (placeholder, as OCR is disabled)."""
    try:
        image = Image.open(image_path)
        # Use pytesseract to extract text from the image (uncomment if OCR is needed)
        # text = pytesseract.image_to_string(image)
        text = ""  # Placeholder since OCR is commented out
        return text.strip()
    except Exception as e:
        log_message(f"Error extracting text from {image_path}: {e}")
        return ""

def generate_caption(image_path):
    """Generate a caption for an image using the BLIP model."""
    try:
        image = Image.open(image_path).convert("RGB")
        inputs = processor(image, return_tensors="pt")
        out = model.generate(**inputs)
        caption = processor.decode(out[0], skip_special_tokens=True)
        return caption.strip()
    except Exception as e:
        log_message(f"Error generating caption for {image_path}: {e}")
        return ""

def get_image_metadata(image_path):
    """Extract metadata from an image."""
    try:
        image = Image.open(image_path)
        exif_data = image._getexif()
        metadata = {}
        
        if exif_data:
            for tag, value in exif_data.items():
                decoded = ExifTags.TAGS.get(tag, tag)
                metadata[decoded] = value
                
        return metadata
    except Exception as e:
        log_message(f"Error extracting metadata from {image_path}: {e}")
        return {}

def get_date_taken(metadata):
    """Extract the date the photo was taken from the metadata."""
    try:
        if 'DateTimeOriginal' in metadata:
            return datetime.strptime(metadata['DateTimeOriginal'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        elif 'DateTime' in metadata:
            return datetime.strptime(metadata['DateTime'], '%Y:%m:%d %H:%M:%S').strftime('%Y-%m-%d')
        else:
            return None
    except Exception as e:
        log_message(f"Error extracting date taken from metadata: {e}")
        return None

def resolve_conflict(directory, base_name, fileext):
    """Resolve naming conflicts by appending a numeric suffix to the base name."""
    counter = 1
    while True:
        new_filename = f"{base_name}{counter:03d}{fileext}"
        if not os.path.exists(os.path.join(directory, new_filename)):
            return new_filename
        counter += 1

def log_message(message, log_filename="ImageRenamer_Log.txt", log_directory="."):
    """Log a message with a timestamp to a specified log file in the target directory."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_path = os.path.join(log_directory, log_filename)
    try:
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(f"[{timestamp}] {message}\n")
    except Exception as e:
        print(f"Error writing to log file: {e}")

def process_images(directory, prepend_date=False, compress=False):
    """Process images in the specified directory: rename them based on extracted text and generated captions."""
    files_exist = any(
        file.lower().endswith(tuple(SUPPORTED_EXTENSIONS))
        for file in os.listdir(directory)
    )
    
    if not files_exist:
        log_message("No image files found with supported extensions.", log_directory=directory)
        print("No image files found with supported extensions.")
        return  # Exit the function if no matching files are found

    for root, _, files in os.walk(directory):
        for file in files:
            # Skip files that end with a number in the range 001 to 009
            if re.search(r"00[1-9]\.\w+$", file.lower()):
                log_message(f"Skipping {file}: ends with a number in the range 001-009.", log_directory=directory)
                continue

            # Process files with supported image extensions
            if file.lower().endswith(tuple(SUPPORTED_EXTENSIONS)):
                image_path = os.path.join(root, file)
                fileext = os.path.splitext(image_path)[1].lower()

                # Convert to JPG if needed (and compress if --COMPRESS is used)
                if fileext != ".jpg" and compress:
                    image_path = convert_to_jpg(image_path)
                    if not image_path:  # Skip if conversion failed
                        continue
                    fileext = ".jpg"
                elif fileext == ".jpg" and compress:
                    image_path = compress_jpg(image_path)
                    if not image_path:  # Skip if compression failed
                        continue

                # Convert HEIC to JPG if needed
                if fileext == ".heic":
                    image_path = convert_heic_to_jpg(image_path)
                    if not image_path:  # Skip if conversion failed
                        continue
                    fileext = ".jpg"

                # Extract date taken from metadata
                metadata = get_image_metadata(image_path)
                date_taken = get_date_taken(metadata) if prepend_date else None

                # Prepend date to the filename if needed
                if prepend_date and date_taken:
                    base_name = f"{date_taken}_{os.path.splitext(file)[0]}"
                else:
                    base_name = os.path.splitext(file)[0]

                # Extract OCR text (currently disabled)
                ocr_text = extract_text_from_image(image_path)

                # Generate image caption
                caption = generate_caption(image_path)

                # Combine OCR text and caption, truncate to 47 characters, and PascalCase
                combined_text = (ocr_text + " " + caption).strip()
                pascal_case_name = "".join(
                    word.capitalize() for word in combined_text.split()
                )[:47]  # Truncate to 47 characters

                # Always add the number suffix (001, 002, etc.)
                if pascal_case_name:
                    base_name = pascal_case_name
                    if prepend_date and date_taken:
                        base_name = f"{date_taken}_{base_name}"

                    new_name = resolve_conflict(root, base_name, fileext)
                    new_path = os.path.join(root, new_name)
                    try:
                        os.rename(image_path, new_path)
                        log_message(f"Renamed {file} to {new_name}", log_directory=directory)
                    except Exception as e:
                        log_message(f"Error renaming {file} to {new_name}: {e}", log_directory=directory)

if __name__ == "__main__":
    # Check for command-line arguments
    prepend_date = "--DATE" in sys.argv
    compress = "--COMPRESS" in sys.argv

    # Get the directory from the command-line argument if provided
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        # Prompt the user for the directory if not provided
        directory = input("Enter the directory path containing images: ")

    if not os.path.isdir(directory):
        print(f"Error: The provided directory '{directory}' does not exist.")
        sys.exit(1)

    process_images(directory, prepend_date, compress)
