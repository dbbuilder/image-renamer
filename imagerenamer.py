"""
ImageRenamer.py

This script renames image files in a specified directory based on extracted text (OCR) and captions generated by an AI model. 
It supports various image formats and allows for preprocessing such as skipping certain files and resolving naming conflicts.

Setup Instructions:
1. Install required packages:
   pip install Pillow transformers
   (Optional: pytesseract if you plan to enable OCR)
2. Ensure Tesseract-OCR is installed if OCR is used. Set the Tesseract path in the script if necessary.
3. Run the script from the command line:
   python ImageRenamer.py <directory_path>
   (Use --DATE parameter if you want to prepend date taken to the file names)

Supported Image Formats: .jpg, .jpeg, .jfif, .png, .bmp, .gif, .webp, .heic
"""

import os
import sys
import re
from datetime import datetime
from PIL import Image
from transformers import BlipProcessor, BlipForConditionalGeneration

# Global constant for supported image file formats
SUPPORTED_EXTENSIONS = [".jpg", ".jpeg", ".jfif", ".png", ".bmp", ".gif", ".webp", ".heic"]

# Initialize the BLIP model and processor for image captioning
processor = BlipProcessor.from_pretrained("Salesforce/blip-image-captioning-base")
model = BlipForConditionalGeneration.from_pretrained(
    "Salesforce/blip-image-captioning-base"
)


def extract_text_from_image(image_path):
    """Extract text from an image using OCR (placeholder, as OCR is disabled)."""
    try:
        image = Image.open(image_path)
        # Use pytesseract to extract text from the image
        # text = pytesseract.image_to_string(image)
        text = ""  # Placeholder since OCR is commented out
        return text.strip()
    except Exception as e:
        log_message(f"Error extracting text from {image_path}: {e}")
        return ""


def generate_caption(image_path):
    """Generate a caption for an image using the BLIP model."""
    try:
        image = Image.open(image_path).convert("RGB")
        inputs = processor(image, return_tensors="pt")
        out = model.generate(**inputs)
        caption = processor.decode(out[0], skip_special_tokens=True)
        return caption.strip()
    except Exception as e:
        log_message(f"Error generating caption for {image_path}: {e}")
        return ""


def resolve_conflict(directory, base_name, fileext):
    """Resolve naming conflicts by appending a numeric suffix to the base name."""
    counter = 1
    while True:
        new_filename = f"{base_name}{counter:03d}{fileext}"
        if not os.path.exists(os.path.join(directory, new_filename)):
            return new_filename
        counter += 1


def log_message(message, log_filename="ImageRenamer_Log.txt", log_directory="."):
    """Log a message with a timestamp to a specified log file in the target directory."""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_path = os.path.join(log_directory, log_filename)
    try:
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(f"[{timestamp}] {message}\n")
    except Exception as e:
        print(f"Error writing to log file: {e}")


def process_images(directory):
    """Process images in the specified directory: rename them based on extracted text and generated captions."""
    files_exist = any(
        file.lower().endswith(tuple(SUPPORTED_EXTENSIONS))
        for file in os.listdir(directory)
    )

    if not files_exist:
        log_message("No image files found with supported extensions.")
        print("No image files found with supported extensions.")
        return  # Exit the function if no matching files are found

    for root, _, files in os.walk(directory):
        for file in files:
            # Skip files that end with a number in the range 001 to 009
            if re.search(r"00[1-9]\.\w+$", file.lower()):
                log_message(
                    f"Skipping {file}: ends with a number in the range 001-009."
                )
                continue

            # Process files with supported image extensions
            if file.lower().endswith(tuple(SUPPORTED_EXTENSIONS)):
                image_path = os.path.join(root, file)
                fileext = os.path.splitext(image_path)[1].lower()

                # Extract OCR text (currently disabled)
                ocr_text = extract_text_from_image(image_path)

                # Generate image caption
                caption = generate_caption(image_path)

                # Combine OCR text and caption, truncate to 47 characters, and PascalCase
                combined_text = (ocr_text + " " + caption).strip()
                pascal_case_name = "".join(
                    word.capitalize() for word in combined_text.split()
                )[
                    :47
                ]  # Truncate to 47 characters

                # Always add the number suffix (001, 002, etc.)
                if pascal_case_name:
                    base_name = pascal_case_name
                    new_name = resolve_conflict(root, base_name, fileext)
                    new_path = os.path.join(root, new_name)
                    try:
                        os.rename(image_path, new_path)
                        log_message(f"Renamed {file} to {new_name}")
                    except Exception as e:
                        log_message(f"Error renaming {file} to {new_name}: {e}")


if __name__ == "__main__":
    # Check for command-line arguments
    prepend_date = "--DATE" in sys.argv

    # Get the directory from the command-line argument if provided
    if len(sys.argv) > 1:
        directory = sys.argv[1]
    else:
        # Prompt the user for the directory if not provided
        directory = input("Enter the directory path containing images: ")

    if not os.path.isdir(directory):
        print(f"Error: The provided directory '{directory}' does not exist.")
        sys.exit(1)

    process_images(directory)
